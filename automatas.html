<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Simulador de Aut√≥mata de Pila</title>
  <link rel="stylesheet" href="style.css"/>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>

  <div class="banner-principal">
    <div class="banner-content">
      Simulador de Aut√≥mata de Pila (PDA)
    </div>
  </div>

  <section id="input-section">
    <div class="input-group">
      <h2>Ejercicio Disponible</h2>
      <p><strong>Ejercicio 4:</strong> L = {x* y¬≤‚Åø z·µê z·µê‚Å∫¬≤ y¬≥‚Åø | n‚â•1, m‚â•1}</p>
    </div>

    <div class="input-group">
      <h2>Ingresa la cadena</h2>
      <input type="text" id="exerciseInput" placeholder="Ejemplo: xyyzzzzyyyyyy">
    </div>

    <button id="generateBtn">Mostrar PDA / Simular</button>
  </section>

  <section id="output-section">
    <h2>ID del Ejercicio</h2>
    <input type="text" id="exerciseID" readonly placeholder="ID generado al simular" class="output-input">

    <h2>Descripci√≥n Formal</h2>
    <textarea id="formalDescription" readonly rows="7" placeholder="Aqu√≠ aparecer√° la descripci√≥n formal del PDA" class="output-textarea"></textarea>

    <h2>Visualizaci√≥n del Aut√≥mata</h2>
    <div id="graph" style="height: 360px;"></div>

    <h2>Simulaci√≥n</h2>
    <div id="simulationSteps" class="steps-box"></div>
  </section>

 <script>
    const generateBtn = document.getElementById("generateBtn");

    function generateID() {
        return "PDA-" + Math.random().toString(36).substr(2, 9).toUpperCase();
    }

    const PDA = {
        Q: "{q0, q1, q2, qf}",
        Sigma: "{x, y, z}",
        Gamma: "{Z, Y}",
        Delta: [
            "(q0, x, Z) -> (q0, Z)",
            "(q0, y, Z) -> (q1, YYZ)", 
            "(q1, y, Y) -> (q1, YYY)", 
            "(q1, z, Y) -> (q2, Œµ)", 
            "(q2, z, Y) -> (q2, Œµ)",
            "(q2, y, Y) -> (q2, Œµ)", 
            "(q2, Œµ, Z) -> (qf, Z)"
        ],
        q0: "q0",
        qf: "qf",

        // -------------------------------------------------------------
        // FUNCI√ìN DE SIMULACI√ìN DIN√ÅMICA (Genera el array de objetos para la tabla)
        // -------------------------------------------------------------
        simulate: input => {
            const detailedSteps = [];
            let stepId = 0;
            let state = "q0";
            let stack = ["Z"];
            let input_index = 0;
            
            // --- VALIDACI√ìN L√ìGICA (PARA MENSAJE FINAL) ---
            const match = input.match(/^(x*)(y+)(z+)(y+)$/);
            if (!match) {
                return { 
                    detailedSteps: [], 
                    acceptanceMessage: "‚ùå Cadena RECHAZADA: No coincide con el patr√≥n general x*y+z+y+." 
                };
            }

            const [_, xPart, y1, zTotal, y2] = match;
            const L_x = xPart.length;
            const L_y1 = y1.length; // 2n
            const L_z = zTotal.length; // 2m + 2
            const L_y2 = y2.length; // 3n
            
            const n = L_y1 % 2 === 0 && L_y1 >= 2 ? L_y1 / 2 : 0;
            const m = (L_z - 2) % 2 === 0 && (L_z - 2) >= 2 ? (L_z - 2) / 2 : 0;

            const cond_y2 = L_y2 === 3 * L_y1;
            const accepted = n >= 1 && m >= 1 && cond_y2;

            // --- FUNCI√ìN AUXILIAR PARA REGISTRAR PASOS ---
            const pushStep = (prev_state, next_state, read_symbol, transition_rule, action_desc, consume_input = true) => {
                const prev_index = consume_input ? input_index - 1 : input_index;
                
                const remaining_input = input.slice(input_index) || 'Œµ';
                const stack_str = stack.length > 0 ? stack.join("") : 'Œµ';
                
                // Formato para la pila (ajustamos el estado de la pila despu√©s de la acci√≥n)
                let display_stack = stack_str.replace(/Y{4}/g, 'Y‚Å¥').replace(/Y{3}/g, 'Y¬≥').replace(/Y{2}/g, 'Y¬≤');
                
                // Determinamos la pila del ID (es la pila ANTES de la transici√≥n)
                let id_stack = (stepId === 0) ? 'Z' : detailedSteps[stepId - 1].stack;
                
                detailedSteps.push({
                    id: stepId++,
                    state: prev_state, 
                    remaining: input.slice(prev_index) || 'Œµ', // Cadena antes de consumir
                    stack: id_stack,
                    read: read_symbol,
                    transition: transition_rule,
                    action: action_desc
                });
                
                state = next_state;
                if (consume_input) input_index++;
            };
            
            let temp_stack_count = 0; 
            
            // --- SIMULACI√ìN ITERATIVA ---

            // 0. Paso inicial (ID 0)
            detailedSteps.push({
                id: stepId++,
                state: 'q0',
                remaining: input,
                stack: 'Z',
                read: 'Inicial',
                transition: 'N/A',
                action: 'Pila inicial Z'
            });

            // 1. Leer x* (q0)
            for (let i = 0; i < L_x; i++) {
                pushStep('q0', 'q0', 'x', '(q0, x, Z) -> (q0, Z)', 'Se mantiene Z');
            }

            // 2. Leer y^(2n) (q0 -> q1 -> q1)
            for (let i = 0; i < L_y1; i++) {
                if (i === 0) {
                    // q0 -> q1 (Consumiendo el primer y)
                    stack.push("Y", "Y");
                    temp_stack_count = 2;
                    pushStep('q0', 'q1', 'y', '(q0, y, Z) -> (q1, YYZ)', `Apila Y Y (total Y${temp_stack_count + 1} Z)`);
                } else {
                    // q1 -> q1 
                    stack.push("Y", "Y");
                    temp_stack_count += 2;
                    pushStep('q1', 'q1', 'y', '(q1, y, Y) -> (q1, YYY)', `Apila Y Y (total Y${temp_stack_count + 1} Z)`);
                }
            }
            
            // 3. Leer z^(2m+2) (q1 -> q2 -> q2)
            for (let i = 0; i < L_z; i++) {
                if (i === 0) {
                    // q1 -> q2 (Consumiendo el primer z)
                    if (stack.length > 1) stack.pop(); // Desapila 1 Y
                    pushStep('q1', 'q2', 'z', '(q1, z, Y) -> (q2, Œµ)', `Desapila Y (total Y${stack.length - 1} Z)`);
                } else if (i < m + 1 && stack.length > 1) { 
                    // El resto de z's que desapilan Y 
                    stack.pop(); 
                    pushStep('q2', 'q2', 'z', '(q2, z, Y) -> (q2, Œµ)', `Desapila Y (total Y${stack.length - 1} Z)`);
                } else {
                    // El resto de z's que no modifican la pila interna (contador m+2)
                    pushStep('q2', 'q2', 'z', '(q2, z, Z) -> (q2, Z)', `Pila no cambia`);
                }
            }

            // 4. Leer y^(3n) (q2 -> q2)
            for (let i = 0; i < L_y2; i++) {
                if (stack.length > 1) { 
                    stack.pop(); // Desapila 1 Y
                }
                pushStep('q2', 'q2', 'y', '(q2, y, Y) -> (q2, Œµ)', `Desapila Y (representa 3n)`);
            }
            
            // 5. Transici√≥n a aceptaci√≥n
            if (input_index === input.length && stack.length === 1 && stack[0] === 'Z') {
                stack.pop(); 
                pushStep('q2', 'qf', 'Œµ', '(q2, Œµ, Z) -> (qf, Œµ)', 'Desapila Z (Cadena Aceptada)', false);
            } else {
                // Si la cadena se agot√≥ y no est√° en estado final o la pila no es Z
                detailedSteps.push({
                    id: stepId++,
                    state: state,
                    remaining: 'Œµ',
                    stack: stack.join('') || 'Œµ',
                    read: 'Rechazo',
                    transition: 'N/A',
                    action: 'Rechazo: Pila/Cadena incorrecta'
                });
            }

            // --- MENSAJE FINAL ---
            const acceptanceMessage = accepted ? 
                '‚úÖ Cadena ACEPTADA (Cumple todas las condiciones de la gram√°tica.)' : 
                '‚ùå Cadena RECHAZADA (La validaci√≥n l√≥gica falla en las condiciones 2n/3n/2m+2.)';
            
            return { detailedSteps, acceptanceMessage };
        }
    };

    function drawGraph(transitions, startState, finalState) {
        // ... (Tu funci√≥n drawGraph se mantiene igual) ...
        const container = document.getElementById("graph");
        const nodes = new Map();
        const edges = [];
        const regex = /\(([A-Za-z0-9_]+),\s*(.*?),\s*(.*?)\)\s*->\s*\(([A-Za-z0-9_]+),\s*(.*?)\)/g;
        transitions.forEach(t => {
            let m;
            while ((m = regex.exec(t)) !== null) {
                const from = m[1], input = m[2], stackTop = m[3], to = m[4], push = m[5];
                if (!nodes.has(from)) nodes.set(from, { id: from, label: from });
                if (!nodes.has(to)) nodes.set(to, { id: to, label: to });
                edges.push({
                    from, to, label: `${input}, ${stackTop}‚Üí${push}`
                });
            }
        });
        const styledNodes = Array.from(nodes.values()).map(n => {
            const style = {
                id: n.id,
                label: n.label,
                shape: "circle",
                color: "#0078d7",
                font: { color: "white" },
                borderWidth: 2
            };
            if (n.id === startState) style.color = "#34c759";
            if (n.id === finalState) {
                style.shape = "ellipse";
                style.borderWidth = 4;
                style.color = "#ffcc00";
            }
            return style;
        });
        const data = { nodes: styledNodes, edges };
        const options = {
            edges: { arrows: "to", color: { color: "#333" }, font: { align: "horizontal" } },
            physics: { enabled: true, stabilization: true }
        };
        container.innerHTML = "";
        new vis.Network(container, data, options);
    }


    // -------------------------------------------------------------
    // EVENT LISTENER (Muestra la tabla)
    // -------------------------------------------------------------
    generateBtn.addEventListener("click", () => {
        const input = document.getElementById("exerciseInput").value.trim();
        const idInput = document.getElementById("exerciseID");
        const outputArea = document.getElementById("formalDescription");
        const stepsDiv = document.getElementById("simulationSteps");

        if (!input) {
            alert("Por favor ingresa una cadena para evaluar.");
            return;
        }

        idInput.value = generateID();
        drawGraph(PDA.Delta, PDA.q0, PDA.qf);
        outputArea.value = `Q: ${PDA.Q}\nŒ£: ${PDA.Sigma}\nŒì: ${PDA.Gamma}\nŒ¥:\n${PDA.Delta.join("\n")}\nq‚ÇÄ: ${PDA.q0}\nqf: ${PDA.qf}`;

        // Obtener el resultado de la simulaci√≥n din√°mica
        const simulationResult = PDA.simulate(input);
        stepsDiv.innerHTML = ''; // Limpiar

        if (simulationResult.detailedSteps) {
            const steps = simulationResult.detailedSteps;
            const acceptanceMessage = simulationResult.acceptanceMessage;
            
            // Estructura de la tabla HTML
            let tableHTML = `
                <style>
                    .simulation-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; margin-top: 15px;}
                    .simulation-table th, .simulation-table td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: top; }
                    .simulation-table th { background-color: #f2f2f2; color: #0078d7; }
                    .simulation-message { margin-top: 15px; font-weight: bold; padding: 10px; border-radius: 5px; }
                    .simulation-message.accepted { background-color: #e6ffe6; color: #008000; }
                    .simulation-message.rejected { background-color: #ffe6e6; color: #cc0000; }
                </style>
                <h3>üìò ID y Pasos de la Simulaci√≥n:</h3>
                <table class="simulation-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>ID (Estado, Cadena Restante, Pila)</th>
                            <th>S√≠mbolo Le√≠do</th>
                            <th>Transici√≥n Œ¥</th>
                            <th>Pila (Acci√≥n)</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            steps.forEach(step => {
                const id_format = `(${step.state}, ${step.remaining}, ${step.stack})`;
                
                tableHTML += `
                    <tr>
                        <td>${step.id}</td>
                        <td style="font-family: monospace;">${id_format}</td>
                        <td>${step.read}</td>
                        <td style="font-family: monospace;">${step.transition}</td>
                        <td>${step.action}</td>
                    </tr>
                `;
            });
            
            tableHTML += '</tbody></table>';
            
            const messageClass = acceptanceMessage.includes('ACEPTADA') ? 'accepted' : 'rejected';
            tableHTML += `<div class="simulation-message ${messageClass}">${acceptanceMessage}</div>`;

            stepsDiv.innerHTML = tableHTML;
        } else {
            // Maneja el caso de cadena que no cumple el patr√≥n inicial
            stepsDiv.innerHTML = `<div class="simulation-message rejected">${simulationResult.acceptanceMessage}</div>`;
        }
    });
</script>
</body>
</html>
