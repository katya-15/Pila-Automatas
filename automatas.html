<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Simulador de Aut√≥mata de Pila</title>
  <link rel="stylesheet" href="style.css"/>
  <link rel="stylesheet" href="styles.css">

<link rel="stylesheet" href="styles.css?v=2">
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>

  <div class="banner-principal">
    <div class="banner-content">
      Simulador de Aut√≥mata de Pila (PDA)
    </div>
  </div>

  <section id="input-section">
    <div class="input-group">
      <h2>Ejercicio Disponible</h2>
      <p><strong>Ejercicio 4:</strong> L = {x* y¬≤‚Åø z·µê z·µê‚Å∫¬≤ y¬≥‚Åø | n‚â•1, m‚â•1}</p>
    </div>

    <div class="input-group">
      <h2>Ingresa la cadena</h2>
      <input type="text" id="exerciseInput" placeholder="Ejemplo: xyyzzzzyyyyyy">
    </div>

    <button id="generateBtn">Mostrar PDA / Simular</button>
  </section>

  <section id="output-section">
    <h2>ID del Ejercicio</h2>
    <input type="text" id="exerciseID" readonly placeholder="ID generado al simular" class="output-input">

    <h2>Descripci√≥n Formal</h2>
    <textarea id="formalDescription" readonly rows="7" placeholder="Aqu√≠ aparecer√° la descripci√≥n formal del PDA" class="output-textarea"></textarea>

    <h2>Visualizaci√≥n del Aut√≥mata</h2>
    <div id="graph" style="height: 360px;"></div>

    <h2>Simulaci√≥n</h2>
    <div id="simulationSteps" class="steps-box"></div>
  </section>

<script>
  const generateBtn = document.getElementById("generateBtn");

  function generateID() {
      return "PDA-" + Math.random().toString(36).substr(2, 9).toUpperCase();
  }


  const PDA = {
    // Estados del aut√≥mata de la imagen
    Q: "{q0, q1, q2, q3, q4, q5}",
    // Alfabeto de entrada
    Sigma: "{x, y, z}",
    // S√≠mbolos de pila
    Gamma: "{Z, 0, 1}",

    // Transiciones (formato igual al que ya usas)
    // (estado, s√≠mbolo_entrada, cima_pila) -> (nuevo_estado, lo_que_se_pone_en_la_pila)
    Delta: [
        // En q0 leo x* y mantengo la pila (solo para permitir x al inicio)
        "(q0, x, Z) -> (q0, Z)",
        "(q0, x, 1) -> (q0, 1)",
        "(q0, x, 0) -> (q0, 0)",

        // Primer y: paso a q1 y empujo 11 sobre lo que haya
        "(q0, y, Z) -> (q1, 11Z)",
        "(q0, y, 1) -> (q1, 111)",
        "(q0, y, 0) -> (q1, 110)",

        // M√°s y del primer bloque: en q1 sigo empujando 11 (y¬≤‚Åø)
        "(q1, y, Z) -> (q1, 11Z)",
        "(q1, y, 1) -> (q1, 111)",
        "(q1, y, 0) -> (q1, 110)",

        // Empiezo primer bloque de z^m: en q1 y q2 cada z empuja 00
        "(q1, z, Z) -> (q2, 00Z)",
        "(q1, z, 1) -> (q2, 001)",
        "(q1, z, 0) -> (q2, 000)",

        "(q2, z, Z) -> (q2, 00Z)",
        "(q2, z, 1) -> (q2, 001)",
        "(q2, z, 0) -> (q2, 000)",

        // Segundo bloque z^{m+2}: ahora los z empiezan a desapilar 0
        "(q2, z, 0) -> (q3, Œª)",
        "(q3, z, 0) -> (q3, Œª)",

        // Bloque final de y¬≥‚Åø: en q3 y q4 cada y empuja 111
        "(q3, y, Z) -> (q4, 111Z)",
        "(q3, y, 1) -> (q4, 1111)",
        "(q3, y, 0) -> (q4, 1110)",

        "(q4, y, Z) -> (q4, 111Z)",
        "(q4, y, 1) -> (q4, 1111)",
        "(q4, y, 0) -> (q4, 1110)",

        // Limpieza de la pila al final: q4 -> q5 borrando 0 y 1 con Œª
        "(q4, Œª, 0) -> (q5, Œª)",
        "(q4, Œª, 1) -> (q5, Œª)",

        // En q5 borro todo lo que quede (incluido Z si aceptas por pila vac√≠a)
        "(q5, Œª, 0) -> (q5, Œª)",
        "(q5, Œª, 1) -> (q5, Œª)",
        "(q5, Œª, Z) -> (q5, Œª)"
    ],

    // Estado inicial y final
    q0: "q0",
    qf: "q5",   // el estado final es q5, como en tu JFLAP

    // El resto de tu objeto (simulate, etc.) lo puedes dejar como ya lo tienes
};

      // FUNCI√ìN DE SIMULACI√ìN DIN√ÅMICA
      // -------------------------------------------------------------
      simulate: input => {
          const detailedSteps = [];
          let stepId = 0;
          let state = "q0";
          let stack = ["Z"];
          let input_index = 0;
          
          // --- VALIDACI√ìN L√ìGICA GLOBAL ---
          const match = input.match(/^(x*)(y+)(z+)(y+)$/);
          if (!match) {
              return { 
                  detailedSteps: [], 
                  acceptanceMessage: "‚ùå Cadena RECHAZADA: No coincide con el patr√≥n general x*y+z+y+.",
                  accepted: false
              };
          }

          const [_, xPart, y1, zTotal, y2] = match;
          const L_x  = xPart.length;
          const L_y1 = y1.length;   // 2n
          const L_z  = zTotal.length; // 2m + 2
          const L_y2 = y2.length;   // 3n
          
          const n = (L_y1 % 2 === 0 && L_y1 >= 2) ? L_y1 / 2 : 0;
          const m = ((L_z - 2) % 2 === 0 && (L_z - 2) >= 2) ? (L_z - 2) / 2 : 0;

          // CORREGIDO: y^(3n)
          const cond_y2 = (n >= 1 && L_y2 === 3 * n);
          const accepted = n >= 1 && m >= 1 && cond_y2;

          // --- FUNCI√ìN AUXILIAR PARA REGISTRAR PASOS ---
          const pushStep = (prev_state, next_state, read_symbol, transition_rule, action_desc, consume_input = true) => {
              const prev_index = consume_input ? input_index - 1 : input_index;
              const remaining_input = input.slice(prev_index) || 'Œµ';

              let stack_str = stack.length > 0 ? stack.join("") : 'Œµ';
              stack_str = stack_str
                  .replace(/Y{4}/g, 'Y‚Å¥')
                  .replace(/Y{3}/g, 'Y¬≥')
                  .replace(/Y{2}/g, 'Y¬≤');

              let id_stack = (stepId === 0) ? 'Z' : detailedSteps[stepId - 1].stack;

              detailedSteps.push({
                  id: stepId++,
                  state: prev_state, 
                  remaining: remaining_input,
                  stack: id_stack,
                  read: read_symbol,
                  transition: transition_rule,
                  action: action_desc
              });
              
              state = next_state;
              if (consume_input) input_index++;
          };
          
          let temp_stack_count = 0; 
          
          // --- PASO INICIAL (ID 0) ---
          detailedSteps.push({
              id: stepId++,
              state: 'q0',
              remaining: input,
              stack: 'Z',
              read: 'Inicial',
              transition: 'N/A',
              action: 'Pila inicial Z'
          });

          // 1. Leer x* (q0)
          for (let i = 0; i < L_x; i++) {
              pushStep('q0', 'q0', 'x', '(q0, x, Z) -> (q0, Z)', 'Se mantiene Z');
          }

          // 2. Leer y^(2n)  (q0 -> q1 -> q1)
          for (let i = 0; i < L_y1; i++) {
              if (i === 0) {
                  // q0 -> q1
                  stack.push("Y", "Y");
                  temp_stack_count = 2;
                  pushStep('q0', 'q1', 'y', '(q0, y, Z) -> (q1, YYZ)', `Apila Y Y (total Y${temp_stack_count + 1} Z)`);
              } else {
                  // q1 -> q1
                  stack.push("Y", "Y");
                  temp_stack_count += 2;
                  pushStep('q1', 'q1', 'y', '(q1, y, Y) -> (q1, YYY)', `Apila Y Y (total Y${temp_stack_count + 1} Z)`);
              }
          }
          
          // 3. Leer z^(2m+2) (q1 -> q2 -> q2)
          for (let i = 0; i < L_z; i++) {
              if (i === 0) {
                  if (stack.length > 1) stack.pop();
                  pushStep('q1', 'q2', 'z', '(q1, z, Y) -> (q2, Œµ)', `Desapila Y (total Y${stack.length - 1} Z)`);
              } else if (i < m + 1 && stack.length > 1) {
                  stack.pop();
                  pushStep('q2', 'q2', 'z', '(q2, z, Y) -> (q2, Œµ)', `Desapila Y (total Y${stack.length - 1} Z)`);
              } else {
                  pushStep('q2', 'q2', 'z', '(q2, z, Z) -> (q2, Z)', 'Pila no cambia');
              }
          }

          // 4. Leer y^(3n) (q2)
          for (let i = 0; i < L_y2; i++) {
              if (stack.length > 1) {
                  stack.pop();
              }
              pushStep('q2', 'q2', 'y', '(q2, y, Y) -> (q2, Œµ)', 'Desapila Y (representa 3n)');
          }
          
          // 5. Transici√≥n de aceptaci√≥n
          if (input_index === input.length && stack.length === 1 && stack[0] === 'Z') {
              stack.pop();
              pushStep('q2', 'qf', 'Œµ', '(q2, Œµ, Z) -> (qf, Œµ)', 'Desapila Z (Cadena Aceptada)', false);
          } else {
              detailedSteps.push({
                  id: stepId++,
                  state: state,
                  remaining: 'Œµ',
                  stack: stack.join('') || 'Œµ',
                  read: 'Rechazo',
                  transition: 'N/A',
                  action: 'Rechazo: Pila/Cadena incorrecta'
              });
          }

          const acceptanceMessage = accepted ? 
              '‚úÖ Cadena ACEPTADA (Cumple todas las condiciones de la gram√°tica.)' : 
              '‚ùå Cadena RECHAZADA (La validaci√≥n l√≥gica falla en las condiciones 2n/3n/2m+2.)';
          
          return { detailedSteps, acceptanceMessage, accepted };
      }
  };

  // -------------------------------------------------------------
  // DIBUJAR EL AUT√ìMATA (ahora depende de si fue aceptada/rechazada)
  // -------------------------------------------------------------
  function drawGraph(transitions, startState, finalState, accepted) {
      const container = document.getElementById("graph");
      const nodes = new Map();
      const edges = [];
      const regex = /\(([A-Za-z0-9_]+),\s*(.*?),\s*(.*?)\)\s*->\s*\(([A-Za-z0-9_]+),\s*(.*?)\)/g;

      transitions.forEach(t => {
          let m;
          while ((m = regex.exec(t)) !== null) {
              const from = m[1], input = m[2], stackTop = m[3], to = m[4], push = m[5];
              if (!nodes.has(from)) nodes.set(from, { id: from, label: from });
              if (!nodes.has(to)) nodes.set(to, { id: to, label: to });
              edges.push({
                  from, 
                  to, 
                  label: `${input}, ${stackTop}‚Üí${push}`
              });
          }
      });

      const styledNodes = Array.from(nodes.values()).map(n => {
          const style = {
              id: n.id,
              label: n.label,
              shape: "circle",
              color: "#0078d7",
              font: { color: "white" },
              borderWidth: 2
          };
          if (n.id === startState) {
              style.color = "#34c759";      // verde inicio
          }
          if (n.id === finalState) {
              style.shape = "ellipse";
              style.borderWidth = 4;
              style.color = accepted ? "#34c759" : "#ff3b30"; // verde si acepta, rojo si rechaza
          }
          return style;
      });

      const data = { 
          nodes: styledNodes, 
          edges 
      };
      const options = {
          edges: { 
              arrows: "to", 
              color: { color: "#333" }, 
              font: { align: "horizontal" } 
          },
          physics: { enabled: true, stabilization: true }
      };
      container.innerHTML = "";
      new vis.Network(container, data, options);
  }

  // -------------------------------------------------------------
  // EVENTO DEL BOT√ìN
  // -------------------------------------------------------------
  generateBtn.addEventListener("click", () => {
      const input = document.getElementById("exerciseInput").value.trim();
      const idInput = document.getElementById("exerciseID");
      const outputArea = document.getElementById("formalDescription");
      const stepsDiv = document.getElementById("simulationSteps");

      if (!input) {
          alert("Por favor ingresa una cadena para evaluar.");
          return;
      }

      idInput.value = generateID();

      // Ejecutar simulaci√≥n
      const simulationResult = PDA.simulate(input);
      const { detailedSteps, acceptanceMessage, accepted } = simulationResult;

      // Dibujar el aut√≥mata resaltando aceptaci√≥n/rechazo
      drawGraph(PDA.Delta, PDA.q0, PDA.qf, accepted);

      // Mostrar descripci√≥n formal
      outputArea.value = `Q: ${PDA.Q}\nŒ£: ${PDA.Sigma}\nŒì: ${PDA.Gamma}\nŒ¥:\n${PDA.Delta.join("\n")}\nq‚ÇÄ: ${PDA.q0}\nqf: ${PDA.qf}`;

      // Limpiar resultados anteriores
      stepsDiv.innerHTML = '';

      if (detailedSteps && detailedSteps.length > 0) {
          const steps = detailedSteps;
          
          let tableHTML = `
              <style>
                  .simulation-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; margin-top: 15px;}
                  .simulation-table th, .simulation-table td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: top; }
                  .simulation-table th { background-color: #f2f2f2; color: #0078d7; }
                  .simulation-message { margin-top: 15px; font-weight: bold; padding: 10px; border-radius: 5px; }
                  .simulation-message.accepted { background-color: #e6ffe6; color: #008000; }
                  .simulation-message.rejected { background-color: #ffe6e6; color: #cc0000; }
              </style>
              <h3>üìò ID y Pasos de la Simulaci√≥n:</h3>
              <table class="simulation-table">
                  <thead>
                      <tr>
                          <th>#</th>
                          <th>ID (Estado, Cadena Restante, Pila)</th>
                          <th>S√≠mbolo Le√≠do</th>
                          <th>Transici√≥n Œ¥</th>
                          <th>Pila (Acci√≥n)</th>
                      </tr>
                  </thead>
                  <tbody>
          `;
          
          steps.forEach(step => {
              const id_format = `(${step.state}, ${step.remaining}, ${step.stack})`;
              
              tableHTML += `
                  <tr>
                      <td>${step.id}</td>
                      <td style="font-family: monospace;">${id_format}</td>
                      <td>${step.read}</td>
                      <td style="font-family: monospace;">${step.transition}</td>
                      <td>${step.action}</td>
                  </tr>
              `;
          });
          
          tableHTML += '</tbody></table>';
          
          const messageClass = accepted ? 'accepted' : 'rejected';
          tableHTML += `<div class="simulation-message ${messageClass}">${acceptanceMessage}</div>`;

          stepsDiv.innerHTML = tableHTML;
      } else {
          stepsDiv.innerHTML = `<div class="simulation-message rejected">${acceptanceMessage}</div>`;
      }
  });
</script>
</body>
</html>
